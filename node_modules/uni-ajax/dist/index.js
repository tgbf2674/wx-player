/*!
 * uni-ajax v2.3.0
 * Developed by ponjs
 * https://github.com/ponjs/uni-ajax
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ajax = factory());
}(this, (function () { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  class InterceptorManager {
    constructor() {
      _defineProperty(this, "handlers", []);
      this.forEach = {
        asc: fn => {
          for (let i = 0, l = this.handlers.length; i < l; i++) {
            this.handlers[i] !== null && fn(this.handlers[i]);
          }
        },
        desc: fn => {
          for (let i = this.handlers.length - 1; i >= 0; i--) {
            this.handlers[i] !== null && fn(this.handlers[i]);
          }
        }
      };
    }
    use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled,
        rejected
      });
      return this.handlers.length - 1;
    }
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
  }

  function RequestConstructor() {
    var _class, _temp;
    return _temp = _class = class Request extends Promise {
      static onHeadersReceived(fn) {
        if (typeof fn === 'function') {
          Request.onHeadersReceivedCallback = fn;
        }
        if (Request.onHeadersReceivedCallback && Request.task) {
          var _Request$task$onHeade, _Request$task;
          (_Request$task$onHeade = (_Request$task = Request.task).onHeadersReceived) === null || _Request$task$onHeade === void 0 ? void 0 : _Request$task$onHeade.call(_Request$task, Request.onHeadersReceivedCallback);
        }
      }
      static offHeadersReceived(fn) {
        if (typeof fn === 'function') {
          Request.offHeadersReceivedCallback = fn;
        }
        if (Request.offHeadersReceivedCallback && Request.task) {
          var _Request$task$offHead, _Request$task2;
          (_Request$task$offHead = (_Request$task2 = Request.task).offHeadersReceived) === null || _Request$task$offHead === void 0 ? void 0 : _Request$task$offHead.call(_Request$task2, Request.offHeadersReceivedCallback);
        }
      }
      abort() {
        var _Request$task3;
        Request.aborted = true;
        (_Request$task3 = Request.task) === null || _Request$task3 === void 0 ? void 0 : _Request$task3.abort();
        return this;
      }
      onHeadersReceived(fn) {
        Request.onHeadersReceived(fn);
        return this;
      }
      offHeadersReceived(fn) {
        Request.offHeadersReceived(fn);
        return this;
      }
    }, _defineProperty(_class, "task", null), _defineProperty(_class, "aborted", false), _defineProperty(_class, "onHeadersReceivedCallback", null), _defineProperty(_class, "offHeadersReceivedCallback", null), _temp;
  }

  function isCallback(field) {
    return ['success', 'fail', 'complete'].includes(field);
  }

  const _toString = Object.prototype.toString;
  function isArray(val) {
    return _toString.call(val) === '[object Array]';
  }
  function isPlainObject(val) {
    return _toString.call(val) === '[object Object]';
  }
  function forEach(obj, fn) {
    if (obj === null || obj === undefined) return;
    if (typeof obj !== 'object') obj = [obj];
    if (isArray(obj)) {
      for (let i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (const k in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, k)) {
          fn.call(null, obj[k], k, obj);
        }
      }
    }
  }
  function merge(...args) {
    const result = {};
    for (let i = 0, l = args.length; i < l; i++) {
      if (isPlainObject(args[i])) {
        forEach(args[i], (val, key) => {
          result[key] = assign(result[key], val);
        });
      }
    }
    return result;
  }
  function assign(target, source) {
    if (isPlainObject(target) && isPlainObject(source)) {
      return merge(target, source);
    } else if (isPlainObject(source)) {
      return merge({}, source);
    } else if (isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function tryCatch(fn) {
    return function () {
      try {
        return fn.apply(fn, arguments);
      } catch (error) {
        console.error(error);
      }
    };
  }

  function detachConfig(url, data, config) {
    let callback = null;
    const options = {};
    const isSingle = typeof url === 'object';
    const value = isSingle ? url : { ...config,
      url,
      data
    };
    forEach(value, (val, key) => {
      if (isSingle && isCallback(key)) {
        (callback || (callback = {}))[key] = tryCatch(val);
      } else {
        options[key] = val;
      }
    });
    return {
      callback,
      config: options
    };
  }

  function mergeConfig(config1, config2 = {}) {
    const config = {};
    const configKeys = Object.keys({ ...config1,
      ...config2
    });
    forEach(configKeys, prop => {
      if (config2[prop] !== undefined) {
        config[prop] = assign(config1[prop], config2[prop]);
      } else if (config1[prop] !== undefined) {
        config[prop] = assign(undefined, config1[prop]);
      }
    });
    config.method = config.method.toUpperCase();
    return config;
  }

  function originURL(baseURL = '') {
    if (!/^https?:\/\//.test(baseURL)) return '';
    const u = baseURL.split('/');
    return u[0] + '//' + u[2];
  }

  function buildURL(url, params) {
    if (!params) return url;
    let query;
    const parts = [];
    forEach(params, (val, key) => {
      if (val === null || typeof val === 'undefined') return;
      if (isArray(val)) key = key + '[]';else val = [val];
      forEach(val, v => {
        if (v !== null && typeof v === 'object') {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });
    query = parts.join('&');
    if (query) {
      const hashmarkIndex = url.indexOf('#');
      hashmarkIndex !== -1 && (url = url.slice(0, hashmarkIndex));
      url += (url.indexOf('?') === -1 ? '?' : '&') + query;
    }
    return url;
  }
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }

  function combineURL(baseURL = '', relativeURL = '') {
    if (/^https?:\/\//.test(relativeURL)) return relativeURL;
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  }

  function adapter(config, Request) {
    return new Promise((resolve, reject) => {
      var _config$xhr;
      if (Request.aborted) {
        return reject({
          config,
          errMsg: 'request:fail abort'
        });
      }
      Request.task = uni.request({ ...config,
        complete: result => {
          const response = {
            config,
            ...result
          };
          !config.validateStatus || config.validateStatus(result.statusCode) ? resolve(response) : reject(response);
        }
      });
      Request.onHeadersReceived();
      Request.offHeadersReceived();
      (_config$xhr = config.xhr) === null || _config$xhr === void 0 ? void 0 : _config$xhr.call(config, Request.task, config);
    });
  }

  const METHOD = ['get', 'post', 'put', 'delete', 'connect', 'head', 'options', 'trace'];
  const HEADER = ['common', ...METHOD];
  const defaults = {
    adapter,
    header: {},
    method: 'get',
    timeout: 30000,
    dataType: 'json',
    responseType: 'text',
    sslVerify: true,
    withCredentials: false,
    firstIpv4: false,
    validateStatus: statusCode => statusCode >= 200 && statusCode < 300
  };
  forEach(HEADER, h => defaults.header[h] = {});

  function dispatchRequest(Request) {
    return config => {
      config.url = buildURL(combineURL(config.baseURL, config.url), config.params);
      config.method = (config.method || 'get').toUpperCase();
      config.header = merge(config.header.common, config.header[config.method.toLowerCase()], config.header);
      forEach(HEADER, h => isPlainObject(config.header[h]) && delete config.header[h]);
      forEach(config, (val, key) => isCallback(key) && delete config[key]);
      return config.adapter(config, Request);
    };
  }

  function dispatchCancel(reason) {
    return Promise.reject({
      reason,
      __CANCEL__: true
    });
  }
  function interceptCancel(rejected) {
    return rejected && (response => response.__CANCEL__ ? Promise.reject(response) : rejected(response));
  }
  function detachCancel({
    __CANCEL__,
    ...error
  }) {
    return Promise.reject(__CANCEL__ ? error.reason : error);
  }

  class Ajax {
    constructor(_config) {
      _defineProperty(this, "request", (...args) => {
        const {
          callback,
          config
        } = detachConfig(...args);
        const Request = RequestConstructor();
        const chain = [dispatchRequest(Request), dispatchCancel];
        this.request.interceptors.request.forEach.desc(({
          fulfilled,
          rejected
        }) => chain.unshift(fulfilled, rejected));
        this.request.interceptors.response.forEach.asc(({
          fulfilled,
          rejected
        }) => chain.push(fulfilled, interceptCancel(rejected)));
        chain.unshift(async config => mergeConfig(await this.config, config), undefined);
        chain.push(undefined, detachCancel);
        chain.push(response => {
          var _callback$success, _callback$complete;
          if (!callback) return response;
          (_callback$success = callback.success) === null || _callback$success === void 0 ? void 0 : _callback$success.call(callback, response);
          (_callback$complete = callback.complete) === null || _callback$complete === void 0 ? void 0 : _callback$complete.call(callback, response);
        }, error => {
          var _callback$fail, _callback$complete2;
          if (!callback) return Promise.reject(error);
          (_callback$fail = callback.fail) === null || _callback$fail === void 0 ? void 0 : _callback$fail.call(callback, error);
          (_callback$complete2 = callback.complete) === null || _callback$complete2 === void 0 ? void 0 : _callback$complete2.call(callback, error);
        });
        let request = Request.resolve(config);
        while (chain.length) {
          request = request.then(chain.shift(), chain.shift());
        }
        return request;
      });
      this.config = _config;
      this.request.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
      this.request.config = async fn => this.config = await fn(this._config);
      forEach(METHOD, method => {
        this.request[method] = (url, data, config) => this.request(...(typeof url === 'string' ? [url, data, { ...config,
          method
        }] : [{ ...url,
          method
        }]));
      });
      setTimeout(async () => {
        this.request.baseURL = (await this.config).baseURL || '';
        this.request.origin = originURL(this.request.baseURL);
      });
    }
    set config(config) {
      this._config = typeof config === 'function' ? async () => mergeConfig(defaults, await config()) : mergeConfig(defaults, config);
    }
    get config() {
      return typeof this._config === 'function' ? this._config() : this._config;
    }
  }

  function createInstance(defaultConfig) {
    return new Ajax(defaultConfig).request;
  }
  const ajax = createInstance();
  ajax.create = function create(instanceConfig) {
    return createInstance(instanceConfig);
  };

  return ajax;

})));
//# sourceMappingURL=index.js.map
